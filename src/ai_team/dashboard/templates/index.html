<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Team Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            padding: 20px;
            min-height: 100vh;
        }
        h1 { color: #58a6ff; margin-bottom: 24px; font-size: 24px; }
        h2 { color: #58a6ff; margin-bottom: 12px; font-size: 18px; }

        /* Connection indicator */
        .ws-status {
            display: inline-block;
            width: 10px; height: 10px;
            border-radius: 50%;
            margin-left: 12px;
            vertical-align: middle;
        }
        .ws-status.connected { background: #238636; }
        .ws-status.disconnected { background: #da3633; }

        /* Section layout */
        .section { margin-bottom: 28px; }

        /* Agent cards grid */
        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin-bottom: 8px;
        }
        .agent-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
        }
        .agent-card h3 {
            color: #58a6ff;
            margin-bottom: 8px;
            font-size: 15px;
        }
        .agent-card .agent-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        /* Status badges */
        .status-badge {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .status-idle { background: #238636; color: #fff; }
        .status-working { background: #1f6feb; color: #fff; }
        .status-blocked { background: #d29922; color: #fff; }
        .status-stopped { background: #da3633; color: #fff; }
        .status-error { background: #da3633; color: #fff; }

        /* Agent control buttons */
        .agent-controls {
            display: flex;
            gap: 6px;
        }
        .btn {
            padding: 4px 12px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #21262d;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .btn:hover { background: #30363d; }
        .btn-pause { border-color: #d29922; color: #d29922; }
        .btn-pause:hover { background: #d29922; color: #fff; }
        .btn-resume { border-color: #238636; color: #3fb950; }
        .btn-resume:hover { background: #238636; color: #fff; }
        .btn-kill { border-color: #da3633; color: #f85149; }
        .btn-kill:hover { background: #da3633; color: #fff; }

        /* Kanban board */
        .kanban-board {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
        }
        .kanban-column {
            min-width: 220px;
            flex: 1;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
        }
        .kanban-column h3 {
            color: #8b949e;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }
        .kanban-column h3 .count {
            background: #30363d;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 6px;
        }
        .task-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .task-card .task-type {
            color: #58a6ff;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .task-card .task-meta {
            color: #8b949e;
            font-size: 11px;
        }

        /* Pipeline runs */
        .runs-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 12px;
        }
        .run-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 14px;
        }
        .run-card .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .run-card .run-id {
            color: #58a6ff;
            font-family: monospace;
            font-size: 13px;
        }
        .run-card .run-pipeline {
            color: #c9d1d9;
            font-size: 14px;
            font-weight: 500;
        }
        .run-card .run-step {
            color: #8b949e;
            font-size: 12px;
        }
        .run-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
        }
        .run-status-running { background: #1f6feb; color: #fff; }
        .run-status-awaiting_approval { background: #d29922; color: #fff; }
        .run-status-completed { background: #238636; color: #fff; }
        .run-status-failed { background: #da3633; color: #fff; }

        /* Approve/Reject buttons */
        .run-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .btn-approve { border-color: #238636; color: #3fb950; }
        .btn-approve:hover { background: #238636; color: #fff; }
        .btn-reject { border-color: #da3633; color: #f85149; }
        .btn-reject:hover { background: #da3633; color: #fff; }

        /* Log stream */
        .log-panel {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid #21262d;
            word-break: break-all;
        }
        .log-entry .log-time {
            color: #8b949e;
            margin-right: 8px;
        }
        .log-entry .log-type {
            color: #d2a8ff;
            font-weight: 500;
            margin-right: 8px;
        }
        .log-entry .log-body {
            color: #c9d1d9;
        }

        /* Empty state */
        .empty-state {
            color: #484f58;
            font-size: 13px;
            font-style: italic;
            padding: 8px 0;
        }

        /* Chat panel */
        .chat-panel {
            position: fixed;
            bottom: 20px;
            width: 380px;
            height: 520px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            transition: height 0.2s ease;
        }
        .chat-panel.minimized {
            height: 44px;
            overflow: hidden;
        }
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #1f6feb;
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            flex-shrink: 0;
        }
        .chat-header .chat-agent-name {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }
        .chat-header .chat-header-btns {
            display: flex;
            gap: 6px;
        }
        .chat-header .chat-header-btns button {
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
            line-height: 1;
        }
        .chat-header .chat-header-btns button:hover {
            color: #fff;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .chat-msg {
            max-width: 85%;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1.5;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .chat-msg.user {
            align-self: flex-end;
            background: #1f6feb;
            color: #fff;
            border-bottom-right-radius: 4px;
        }
        .chat-msg.assistant {
            align-self: flex-start;
            background: #21262d;
            color: #c9d1d9;
            border-bottom-left-radius: 4px;
        }
        .chat-msg.system {
            align-self: center;
            background: none;
            color: #8b949e;
            font-style: italic;
            font-size: 12px;
            text-align: center;
        }
        .chat-msg.streaming {
            border: 1px solid #1f6feb;
        }
        .chat-input-area {
            display: flex;
            gap: 8px;
            padding: 10px 12px;
            border-top: 1px solid #30363d;
            flex-shrink: 0;
        }
        .chat-input-area input {
            flex: 1;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 8px 12px;
            color: #c9d1d9;
            font-size: 13px;
            outline: none;
        }
        .chat-input-area input:focus {
            border-color: #1f6feb;
        }
        .chat-input-area input:disabled {
            opacity: 0.5;
        }
        .chat-input-area button {
            background: #1f6feb;
            border: none;
            border-radius: 8px;
            color: #fff;
            padding: 8px 16px;
            font-size: 13px;
            cursor: pointer;
            font-weight: 500;
        }
        .chat-input-area button:hover {
            background: #388bfd;
        }
        .chat-input-area button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Chat button for agent cards */
        .btn-chat {
            border-color: #1f6feb;
            color: #58a6ff;
        }
        .btn-chat:hover {
            background: #1f6feb;
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>
        AI Team Dashboard
        <span id="wsIndicator" class="ws-status disconnected" title="WebSocket disconnected"></span>
    </h1>

    <!-- Agents Section -->
    <div class="section">
        <h2>Agents</h2>
        <div class="agents-grid" id="agentsGrid">
            <div class="empty-state">No agents spawned yet.</div>
        </div>
    </div>

    <!-- Kanban Task Board -->
    <div class="section">
        <h2>Task Board</h2>
        <div class="kanban-board" id="kanbanBoard">
            <div class="kanban-column" id="col-pending">
                <h3>Pending <span class="count">0</span></h3>
                <div class="column-tasks"></div>
            </div>
            <div class="kanban-column" id="col-in_progress">
                <h3>In Progress <span class="count">0</span></h3>
                <div class="column-tasks"></div>
            </div>
            <div class="kanban-column" id="col-review">
                <h3>Review <span class="count">0</span></h3>
                <div class="column-tasks"></div>
            </div>
            <div class="kanban-column" id="col-completed">
                <h3>Completed <span class="count">0</span></h3>
                <div class="column-tasks"></div>
            </div>
            <div class="kanban-column" id="col-failed">
                <h3>Failed <span class="count">0</span></h3>
                <div class="column-tasks"></div>
            </div>
        </div>
    </div>

    <!-- Pipeline Runs -->
    <div class="section">
        <h2>Pipeline Runs</h2>
        <div class="runs-list" id="runsList">
            <div class="empty-state">No active pipeline runs.</div>
        </div>
    </div>

    <!-- Real-time Log Stream -->
    <div class="section">
        <h2>Event Log</h2>
        <div class="log-panel" id="logPanel">
            <div class="empty-state">Waiting for events...</div>
        </div>
    </div>

    <script>
        // --- State ---
        let ws = null;
        let reconnectTimer = null;
        const MAX_LOG_ENTRIES = 200;

        // --- WebSocket ---
        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws`);

            ws.onopen = () => {
                document.getElementById('wsIndicator').className = 'ws-status connected';
                document.getElementById('wsIndicator').title = 'WebSocket connected';
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }
                // Initial data load
                refreshAll();
            };

            ws.onmessage = (e) => {
                const event = JSON.parse(e.data);
                appendLog(event);
                // Refresh relevant sections based on event type
                if (event.type && (event.type.includes('agent') || event.type.includes('team'))) {
                    refreshAgents();
                }
                if (event.type && (event.type.includes('task') || event.type.includes('pipeline'))) {
                    refreshTaskBoard();
                    refreshRuns();
                }
                if (event.type && event.type.includes('checkpoint')) {
                    refreshRuns();
                }
            };

            ws.onclose = () => {
                document.getElementById('wsIndicator').className = 'ws-status disconnected';
                document.getElementById('wsIndicator').title = 'WebSocket disconnected - reconnecting...';
                reconnectTimer = setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = () => {
                ws.close();
            };
        }

        // --- Log Stream ---
        function appendLog(event) {
            const logPanel = document.getElementById('logPanel');
            // Remove empty state if present
            const emptyState = logPanel.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const time = new Date().toLocaleTimeString();
            const type = event.type || 'unknown';
            const body = JSON.stringify(event, null, 0);

            entry.innerHTML =
                '<span class="log-time">' + escapeHtml(time) + '</span>' +
                '<span class="log-type">' + escapeHtml(type) + '</span>' +
                '<span class="log-body">' + escapeHtml(body) + '</span>';

            logPanel.prepend(entry);

            // Trim old entries
            const entries = logPanel.querySelectorAll('.log-entry');
            if (entries.length > MAX_LOG_ENTRIES) {
                for (let i = MAX_LOG_ENTRIES; i < entries.length; i++) {
                    entries[i].remove();
                }
            }
        }

        // --- Agents ---
        async function refreshAgents() {
            try {
                const resp = await fetch('/api/team');
                const team = await resp.json();
                const grid = document.getElementById('agentsGrid');

                if (Object.keys(team).length === 0) {
                    grid.innerHTML = '<div class="empty-state">No agents spawned yet.</div>';
                    return;
                }

                grid.innerHTML = '';
                for (const [name, status] of Object.entries(team)) {
                    const card = document.createElement('div');
                    card.className = 'agent-card';
                    card.innerHTML =
                        '<div class="agent-info">' +
                            '<h3>' + escapeHtml(name) + '</h3>' +
                            '<span class="status-badge status-' + escapeHtml(status) + '">' + escapeHtml(status) + '</span>' +
                        '</div>' +
                        '<div class="agent-controls">' +
                            '<button class="btn btn-chat" onclick="openChat(\'' + escapeHtml(name) + '\')">Chat</button>' +
                            '<button class="btn btn-pause" onclick="agentAction(\'' + escapeHtml(name) + '\', \'pause\')">Pause</button>' +
                            '<button class="btn btn-resume" onclick="agentAction(\'' + escapeHtml(name) + '\', \'resume\')">Resume</button>' +
                            '<button class="btn btn-kill" onclick="agentAction(\'' + escapeHtml(name) + '\', \'kill\')">Kill</button>' +
                        '</div>';
                    grid.appendChild(card);
                }
            } catch (err) {
                console.error('Failed to refresh agents:', err);
            }
        }

        async function agentAction(name, action) {
            try {
                const resp = await fetch('/api/agents/' + encodeURIComponent(name) + '/' + action, { method: 'POST' });
                if (resp.ok) {
                    refreshAgents();
                }
            } catch (err) {
                console.error('Agent action failed:', err);
            }
        }

        // --- Kanban Task Board ---
        async function refreshTaskBoard() {
            try {
                const resp = await fetch('/api/tasks/board');
                const board = await resp.json();

                const columns = ['pending', 'in_progress', 'review', 'completed', 'failed'];
                for (const col of columns) {
                    const colEl = document.getElementById('col-' + col);
                    if (!colEl) continue;

                    const tasks = board[col] || [];
                    const countEl = colEl.querySelector('.count');
                    if (countEl) countEl.textContent = tasks.length;

                    const tasksContainer = colEl.querySelector('.column-tasks');
                    tasksContainer.innerHTML = '';

                    for (const task of tasks) {
                        const card = document.createElement('div');
                        card.className = 'task-card';
                        card.innerHTML =
                            '<div class="task-type">' + escapeHtml(task.task_type || 'task') + '</div>' +
                            '<div class="task-meta">' +
                                'ID: ' + escapeHtml(String(task.id || '')) +
                                (task.assigned_to ? ' | Agent: ' + escapeHtml(task.assigned_to) : '') +
                                (task.pipeline_id ? ' | Pipeline: ' + escapeHtml(task.pipeline_id) : '') +
                            '</div>';
                        tasksContainer.appendChild(card);
                    }

                    if (tasks.length === 0) {
                        tasksContainer.innerHTML = '<div class="empty-state">No tasks</div>';
                    }
                }
            } catch (err) {
                console.error('Failed to refresh task board:', err);
            }
        }

        // --- Pipeline Runs ---
        async function refreshRuns() {
            try {
                const resp = await fetch('/api/runs');
                const runs = await resp.json();
                const runsList = document.getElementById('runsList');

                if (runs.length === 0) {
                    runsList.innerHTML = '<div class="empty-state">No active pipeline runs.</div>';
                    return;
                }

                runsList.innerHTML = '';
                for (const run of runs) {
                    const card = document.createElement('div');
                    card.className = 'run-card';

                    let statusClass = 'run-status-' + (run.status || 'running');
                    let actionsHtml = '';
                    if (run.status === 'awaiting_approval') {
                        actionsHtml =
                            '<div class="run-actions">' +
                                '<button class="btn btn-approve" onclick="approveRun(\'' + escapeHtml(run.run_id) + '\')">Approve</button>' +
                                '<button class="btn btn-reject" onclick="rejectRun(\'' + escapeHtml(run.run_id) + '\')">Reject</button>' +
                            '</div>';
                    }

                    card.innerHTML =
                        '<div class="run-header">' +
                            '<span class="run-pipeline">' + escapeHtml(run.pipeline || '') + '</span>' +
                            '<span class="run-status ' + statusClass + '">' + escapeHtml(run.status || '') + '</span>' +
                        '</div>' +
                        '<div class="run-id">Run: ' + escapeHtml(run.run_id || '') + '</div>' +
                        '<div class="run-step">Step: ' + (run.current_step != null ? run.current_step : '?') + '</div>' +
                        actionsHtml;

                    runsList.appendChild(card);
                }
            } catch (err) {
                console.error('Failed to refresh runs:', err);
            }
        }

        async function approveRun(runId) {
            try {
                await fetch('/api/runs/' + encodeURIComponent(runId) + '/approve', { method: 'POST' });
                refreshRuns();
            } catch (err) {
                console.error('Approve failed:', err);
            }
        }

        async function rejectRun(runId) {
            try {
                await fetch('/api/runs/' + encodeURIComponent(runId) + '/reject', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reason: 'Rejected from dashboard' })
                });
                refreshRuns();
            } catch (err) {
                console.error('Reject failed:', err);
            }
        }

        // --- Utilities ---
        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function refreshAll() {
            refreshAgents();
            refreshTaskBoard();
            refreshRuns();
        }

        // --- Chat System ---
        const chatPanels = {};  // agent_name -> { ws, panelEl, messagesEl, inputEl, sendBtn, streamingEl }
        let chatPanelCount = 0;

        function openChat(agentName) {
            // If already open, focus it
            if (chatPanels[agentName]) {
                chatPanels[agentName].panelEl.classList.remove('minimized');
                chatPanels[agentName].inputEl.focus();
                return;
            }

            // Create panel element
            const panel = document.createElement('div');
            panel.className = 'chat-panel';
            panel.style.right = (20 + chatPanelCount * 400) + 'px';
            panel.id = 'chat-panel-' + agentName;

            panel.innerHTML =
                '<div class="chat-header" onclick="minimizeChat(\'' + escapeHtml(agentName) + '\')">' +
                    '<span class="chat-agent-name">' + escapeHtml(agentName) + '</span>' +
                    '<div class="chat-header-btns">' +
                        '<button onclick="event.stopPropagation(); minimizeChat(\'' + escapeHtml(agentName) + '\')" title="Minimize">&minus;</button>' +
                        '<button onclick="event.stopPropagation(); closeChat(\'' + escapeHtml(agentName) + '\')" title="Close">&times;</button>' +
                    '</div>' +
                '</div>' +
                '<div class="chat-messages" id="chat-messages-' + agentName + '"></div>' +
                '<div class="chat-input-area">' +
                    '<input type="text" id="chat-input-' + agentName + '" placeholder="Type a message..." ' +
                        'onkeydown="if(event.key===\'Enter\')sendChatMessage(\'' + escapeHtml(agentName) + '\')" disabled />' +
                    '<button id="chat-send-' + agentName + '" onclick="sendChatMessage(\'' + escapeHtml(agentName) + '\')" disabled>Send</button>' +
                '</div>';

            document.body.appendChild(panel);

            const messagesEl = document.getElementById('chat-messages-' + agentName);
            const inputEl = document.getElementById('chat-input-' + agentName);
            const sendBtn = document.getElementById('chat-send-' + agentName);

            // Connect WebSocket
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const chatWs = new WebSocket(`${protocol}//${location.host}/ws/chat/${encodeURIComponent(agentName)}`);

            chatPanels[agentName] = {
                ws: chatWs,
                panelEl: panel,
                messagesEl: messagesEl,
                inputEl: inputEl,
                sendBtn: sendBtn,
                streamingEl: null
            };

            chatPanelCount++;

            appendChatBubble(agentName, 'system', 'Connecting...');

            chatWs.onopen = () => {
                chatWs.send(JSON.stringify({ type: 'start_session' }));
            };

            chatWs.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                handleChatMessage(agentName, msg);
            };

            chatWs.onclose = () => {
                appendChatBubble(agentName, 'system', 'Disconnected.');
                inputEl.disabled = true;
                sendBtn.disabled = true;
            };

            chatWs.onerror = () => {
                appendChatBubble(agentName, 'system', 'Connection error.');
            };
        }

        function handleChatMessage(agentName, msg) {
            const chat = chatPanels[agentName];
            if (!chat) return;

            switch (msg.type) {
                case 'session_started':
                    appendChatBubble(agentName, 'system', 'Connected to ' + agentName + '.');
                    chat.inputEl.disabled = false;
                    chat.sendBtn.disabled = false;
                    chat.inputEl.focus();
                    break;

                case 'chat_token':
                    // Streaming token â€” append to existing streaming bubble or create one
                    if (!chat.streamingEl) {
                        chat.streamingEl = document.createElement('div');
                        chat.streamingEl.className = 'chat-msg assistant streaming';
                        chat.streamingEl.textContent = '';
                        chat.messagesEl.appendChild(chat.streamingEl);
                    }
                    chat.streamingEl.textContent += msg.content;
                    chat.messagesEl.scrollTop = chat.messagesEl.scrollHeight;
                    break;

                case 'chat_tool_use':
                    appendChatBubble(agentName, 'system', 'Using tool: ' + (msg.tool || 'unknown'));
                    break;

                case 'chat_response_complete':
                    // Finalize streaming bubble
                    if (chat.streamingEl) {
                        chat.streamingEl.classList.remove('streaming');
                        chat.streamingEl = null;
                    }
                    chat.inputEl.disabled = false;
                    chat.sendBtn.disabled = false;
                    chat.inputEl.focus();
                    break;

                case 'chat_error':
                    appendChatBubble(agentName, 'system', 'Error: ' + (msg.error || 'Unknown error'));
                    chat.inputEl.disabled = false;
                    chat.sendBtn.disabled = false;
                    break;

                case 'session_stopped':
                    appendChatBubble(agentName, 'system', 'Session ended.');
                    break;
            }
        }

        function sendChatMessage(agentName) {
            const chat = chatPanels[agentName];
            if (!chat || !chat.ws) return;

            const text = chat.inputEl.value.trim();
            if (!text) return;

            // Show user message
            appendChatBubble(agentName, 'user', text);
            chat.inputEl.value = '';

            // Disable input while waiting
            chat.inputEl.disabled = true;
            chat.sendBtn.disabled = true;

            // Send to server
            chat.ws.send(JSON.stringify({ type: 'chat_message', content: text }));
        }

        function closeChat(agentName) {
            const chat = chatPanels[agentName];
            if (!chat) return;

            // Send stop_session if connected
            if (chat.ws && chat.ws.readyState === WebSocket.OPEN) {
                chat.ws.send(JSON.stringify({ type: 'stop_session' }));
            }
            chat.ws.close();

            // Remove panel from DOM
            chat.panelEl.remove();
            delete chatPanels[agentName];
            chatPanelCount = Math.max(0, chatPanelCount - 1);
        }

        function minimizeChat(agentName) {
            const chat = chatPanels[agentName];
            if (!chat) return;
            chat.panelEl.classList.toggle('minimized');
        }

        function appendChatBubble(agentName, role, text) {
            const chat = chatPanels[agentName];
            if (!chat) return;

            const bubble = document.createElement('div');
            bubble.className = 'chat-msg ' + role;
            bubble.textContent = text;
            chat.messagesEl.appendChild(bubble);
            chat.messagesEl.scrollTop = chat.messagesEl.scrollHeight;
        }

        // --- Init ---
        connectWebSocket();
    </script>
</body>
</html>
